---
# ============================================================================
# Infrastructure Setup Playbook
# ============================================================================
#
# Run this ONCE when setting up a new server.
# Installs: Docker, MicroK8s, system packages
#
# USAGE:
#   ansible-playbook -i inventory-production.yml setup-infrastructure.yml
#
# TIME: ~5-8 minutes
#
# ============================================================================

- name: Setup Infrastructure (Docker + MicroK8s)
  hosts: production-server
  become: yes
  gather_facts: yes

  tasks:
    # ============================================================
    # System Packages
    # ============================================================
    - name: Update apt cache
      apt:
        update_cache: yes
        cache_valid_time: 3600

    - name: Install required system packages
      apt:
        name:
          - apt-transport-https
          - ca-certificates
          - curl
          - gnupg
          - lsb-release
          - python3-pip
          - python3-docker
          - rsync
          - snapd
        state: present

    # ============================================================
    # Docker
    # ============================================================
    - name: Add Docker GPG key
      apt_key:
        url: https://download.docker.com/linux/ubuntu/gpg
        state: present

    - name: Detect system architecture
      set_fact:
        docker_arch: "{{ 'arm64' if ansible_architecture == 'aarch64' else 'amd64' }}"

    - name: Add Docker repository
      apt_repository:
        repo: "deb [arch={{ docker_arch }}] https://download.docker.com/linux/ubuntu {{ ansible_distribution_release }} stable"
        state: present

    - name: Install Docker
      apt:
        name:
          - docker-ce
          - docker-ce-cli
          - containerd.io
        state: present

    - name: Start and enable Docker service
      systemd:
        name: docker
        state: started
        enabled: yes

    - name: Add user to docker group
      user:
        name: "{{ ansible_user }}"
        groups: docker
        append: yes

    # ============================================================
    # Persistent Storage Setup (EBS)
    # ============================================================
    - name: Detect EBS volume by ID (Terraform)
      shell: |
        # Remove 'vol-' prefix to get serial for NVMe (e.g. vol-123 -> vol123)
        VOL_ID_CLEAN=$(echo "{{ ebs_volume_id }}" | sed 's/-//')
        # Find device with that serial
        lsblk -d -o NAME,SERIAL | grep "$VOL_ID_CLEAN" | awk '{print "/dev/"$1}'
      register: ebs_device_from_id
      when: ebs_volume_id is defined
      changed_when: false

    - name: Set EBS device path (from ID)
      set_fact:
        ebs_device: "{{ ebs_device_from_id.stdout | trim }}"
      when: ebs_volume_id is defined and ebs_device_from_id.stdout != ""

    - name: Detect EBS volume (Fallback/Manual)
      shell: |
        # Check for the specific device name first
        if [ -b /dev/sdf ]; then
          echo "/dev/sdf"
        # Check for NVMe device (usually nvme1n1 if root is nvme0n1)
        elif [ -b /dev/nvme1n1 ]; then
          echo "/dev/nvme1n1"
        else
          # Find by size (64G)
          lsblk -dn -o NAME,SIZE | grep '64G' | awk '{print "/dev/"$1}' | head -n1
        fi
      register: ebs_device_fallback
      when: ebs_device is not defined or ebs_device == ""
      changed_when: false

    - name: Set EBS device path (Fallback)
      set_fact:
        ebs_device: "{{ ebs_device_fallback.stdout | trim }}"
      when: (ebs_device is not defined or ebs_device == "") and ebs_device_fallback.stdout != ""

    - name: Fail if EBS device not found
      fail:
        msg: "Could not detect 64GB EBS volume. Please check attachment."
      when: ebs_device == ""

    - name: Display detected EBS device
      debug:
        msg: "Detected EBS device: {{ ebs_device }}"

    - name: Check if MicroK8s is installed
      command: snap list microk8s
      register: microk8s_installed
      failed_when: false
      changed_when: false

    - name: Check if EBS volume is already mounted
      shell: mount | grep "{{ ebs_device }}"
      register: ebs_mounted
      failed_when: false
      changed_when: false

    - name: Stop MicroK8s if installed and volume not mounted (to release file handles)
      command: microk8s stop
      when:
        - microk8s_installed.rc is defined
        - microk8s_installed.rc == 0
        - ebs_mounted.rc != 0
      ignore_errors: yes

    - name: Wait for MicroK8s to fully stop
      wait_for:
        timeout: 30
      when:
        - microk8s_installed.rc is defined
        - microk8s_installed.rc == 0
        - ebs_mounted.rc != 0

    - name: Create ext4 filesystem on EBS volume
      filesystem:
        fstype: ext4
        dev: "{{ ebs_device }}"
      when: ebs_mounted.rc != 0

    - name: Create mount point for MicroK8s data
      file:
        path: /var/snap/microk8s/common
        state: directory
        mode: "0755"
      when: ebs_mounted.rc != 0

    - name: Mount EBS volume
      mount:
        path: /var/snap/microk8s/common
        src: "{{ ebs_device }}"
        fstype: ext4
        opts: defaults,nofail
        state: mounted
      when: ebs_mounted.rc != 0

    - name: Ensure EBS volume is in fstab (even if already mounted)
      mount:
        path: /var/snap/microk8s/common
        src: "{{ ebs_device }}"
        fstype: ext4
        opts: defaults,nofail
        state: present

    # ============================================================
    # Backup Tools
    # ============================================================
    - name: Install AWS CLI
      snap:
        name: aws-cli
        classic: yes
        state: present

    - name: Create backup script
      copy:
        dest: /usr/local/bin/backup-k8s-to-s3.sh
        mode: "0755"
        content: |
          #!/bin/bash
          BACKUP_DATE=$(date +%Y-%m-%d_%H-%M-%S)
          BACKUP_FILE="/tmp/k8s-backup-$BACKUP_DATE.tar.gz"

          # Backup MicroK8s data
          tar -czf $BACKUP_FILE /var/snap/microk8s/common

          # Upload to S3
          aws s3 cp $BACKUP_FILE s3://cecre-k8/backups/

          # Cleanup local backup
          rm $BACKUP_FILE

    - name: Setup daily backup cron job
      cron:
        name: "Backup MicroK8s to S3"
        minute: "0"
        hour: "2"
        job: "/usr/local/bin/backup-k8s-to-s3.sh >> /var/log/k8s-backup.log 2>&1"

    # ============================================================
    # MicroK8s
    # ============================================================
    - name: Install MicroK8s via snap
      snap:
        name: microk8s
        classic: yes
        channel: "1.28/stable"

    - name: Ensure MicroK8s is running
      command: microk8s start
      changed_when: false
      failed_when: false

    - name: Wait for MicroK8s to be ready
      command: microk8s status --wait-ready
      changed_when: false
      retries: 10
      delay: 10
      register: microk8s_ready
      until: microk8s_ready.rc == 0

    - name: Enable MicroK8s addons
      command: "microk8s enable {{ item }}"
      loop:
        - dns
        - storage
        - ingress
      register: addon_result
      changed_when: "'Enabling' in addon_result.stdout"
      retries: 5
      delay: 10
      until: addon_result.rc == 0

    - name: Wait for Ingress controller to be ready
      command: microk8s kubectl wait --for=condition=ready pod -l name=nginx-ingress-microk8s -n ingress --timeout=300s
      changed_when: false
      failed_when: false
      retries: 3
      delay: 10

    - name: Patch Ingress controller to use host network
      shell: |
        microk8s kubectl patch daemonset nginx-ingress-microk8s-controller \
          -n ingress \
          --type=json \
          -p='[{"op": "add", "path": "/spec/template/spec/hostNetwork", "value": true}]'
      register: patch_result
      changed_when: "'patched' in patch_result.stdout"
      failed_when: false

    - name: Restart Ingress controller pods to apply host network
      shell: |
        microk8s kubectl delete pod -n ingress -l name=nginx-ingress-microk8s
      when: patch_result.changed
      changed_when: true

    - name: Wait for Ingress controller to be ready after restart
      command: microk8s kubectl wait --for=condition=ready pod -l name=nginx-ingress-microk8s -n ingress --timeout=300s
      when: patch_result.changed
      changed_when: false
      retries: 3
      delay: 10

    - name: Add user to microk8s group
      user:
        name: "{{ ansible_user }}"
        groups: microk8s
        append: yes

    - name: Create kubectl alias
      lineinfile:
        path: "/home/{{ ansible_user }}/.bashrc"
        line: "alias kubectl='microk8s kubectl'"
        create: yes

    - name: Set up kubectl config
      shell: |
        mkdir -p /home/{{ ansible_user }}/.kube
        microk8s config > /home/{{ ansible_user }}/.kube/config
        chown -R {{ ansible_user }}:{{ ansible_user }} /home/{{ ansible_user }}/.kube
      args:
        creates: "/home/{{ ansible_user }}/.kube/config"

    # ============================================================
    # Firewall (Basic Setup)
    # ============================================================
    - name: Allow SSH (CRITICAL!)
      ufw:
        rule: allow
        port: "22"
        proto: tcp
        comment: "SSH access"

    - name: Allow HTTP traffic
      ufw:
        rule: allow
        port: "80"
        proto: tcp
        comment: "HTTP traffic"

    - name: Allow HTTPS traffic
      ufw:
        rule: allow
        port: "443"
        proto: tcp
        comment: "HTTPS traffic"

    - name: Allow Kubernetes NodePort range
      ufw:
        rule: allow
        from_ip: any
        to_port: "30000:32767"
        proto: tcp
        comment: "Kubernetes NodePort range"

    - name: Enable UFW
      ufw:
        state: enabled

    # ============================================================
    # Summary
    # ============================================================
    - name: Display infrastructure setup summary
      debug:
        msg: |

          âœ… Infrastructure Setup Complete!

          Installed:
            - Docker
            - MicroK8s with dns, storage, ingress
            - Firewall configured

          Next steps:
            1. Deploy app: ansible-playbook -i inventory-production.yml deploy-app.yml
            2. Or add monitoring: ansible-playbook -i inventory-production.yml deploy-monitoring.yml

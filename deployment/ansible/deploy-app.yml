---
# ============================================================================
# Application Deployment Playbook
# ============================================================================
#
# PURPOSE:
#   Deploy or update the School Portal application on the production server.
#   This version is CI/CD ready â€” intended to be triggered automatically by
#   GitHub Actions on a self-hosted runner (same server where MicroK8s runs).
#
# USAGE (manual):
#   ansible-playbook -i inventory-production.yml deploy-app.yml
#
# DEPLOYMENT TIME: ~2-3 minutes
#
# PREREQUISITES:
#   - Infrastructure setup complete (run setup-infrastructure.yml first)
#   - Docker image already pushed to Docker Hub
#   - `.env` file is generated by GitHub Actions and placed in repo root
#
# ============================================================================

- name: Deploy School Portal Application
  hosts: production-server
  become: yes
  gather_facts: yes

  vars:
    # Logic: Use Domain if (use_ip is false AND domain is set), otherwise use IP
    use_domain: "{{ not use_ip|bool and production_domain|default('')|length > 0 }}"
    redirect_uri: "{{ 'https://' + production_domain if use_domain else ('https://' + production_ip + ':30443' if use_https|bool else 'http://' + production_ip + ':3000') }}"
    https_port: "{{ 443 if use_domain else (3443 if use_https|bool else 443) }}"
    app_path: "/opt/{{ app_name }}"
    certs_path: "/opt/{{ app_name }}/certs"

  tasks:
    # ============================================================
    # Prepare Application Directory
    # ============================================================
    - name: Create application directory
      file:
        path: "{{ app_path }}"
        state: directory
        mode: "0755"

    - name: Copy .env file from workflow
      copy:
        src: "{{ playbook_dir }}/../../.env"
        dest: "{{ app_path }}/.env"
        mode: "0600"
      when: lookup('file', playbook_dir + '/../../.env', errors='ignore') != ''
      changed_when: true

    - name: Create certs directory
      file:
        path: "{{ certs_path }}"
        state: directory
        mode: "0755"

    - name: Generate self-signed SSL certificate if not exists
      command: >
        openssl req -x509 -nodes -days 365 -newkey rsa:2048
        -keyout {{ certs_path }}/key.pem
        -out {{ certs_path }}/cert.pem
        -subj "/C=US/ST=State/L=City/O=Organization/CN={{ production_ip }}"
      args:
        creates: "{{ certs_path }}/cert.pem"
      changed_when: true

    - name: Set certificate permissions
      file:
        path: "{{ certs_path }}/{{ item }}"
        mode: "0644"
      loop:
        - cert.pem
        - key.pem
      changed_when: false

    # ============================================================
    # Pull Docker Image and Import into MicroK8s
    # ============================================================
    - name: Pull Docker image from Docker Hub
      community.docker.docker_image:
        name: "{{ docker_registry }}:{{ app_version }}"
        source: pull
      register: pull_result
      changed_when: "'Pulled' in (pull_result.actions | join(' '))"

    - name: Import image into MicroK8s containerd
      shell: |
        docker save {{ docker_registry }}:{{ app_version }} -o /tmp/app-{{ app_version }}.tar
        microk8s ctr images import /tmp/app-{{ app_version }}.tar
        rm /tmp/app-{{ app_version }}.tar
      args:
        executable: /bin/bash
      changed_when: true

    # ============================================================
    # Create/Update Kubernetes Resources
    # ============================================================
    - name: Create clean .env file for Kubernetes secrets
      shell: |
        awk -F'=' '!seen[$1]++ && $1 !~ /^#/ && $1 !~ /^CERT_PATH$/ && $1 !~ /^KEY_PATH$/' {{ app_path }}/.env > {{ app_path }}/.env.k8s
      args:
        executable: /bin/bash
      changed_when: true

    - name: Create or update Kubernetes secret
      shell: |
        /snap/bin/microk8s kubectl create secret generic school-portal-secrets \
          --from-env-file={{ app_path }}/.env.k8s \
          --namespace={{ k8s_namespace }} \
          --dry-run=client -o yaml | /snap/bin/microk8s kubectl apply -f -
      args:
        executable: /bin/bash
      changed_when: true

    - name: Create or update SSL certificate ConfigMap
      shell: |
        /snap/bin/microk8s kubectl create configmap ssl-certs \
          --from-file=cert.pem={{ certs_path }}/cert.pem \
          --from-file=key.pem={{ certs_path }}/key.pem \
          --namespace={{ k8s_namespace }} \
          --dry-run=client -o yaml | /snap/bin/microk8s kubectl apply -f -
      args:
        executable: /bin/bash
      changed_when: true

    # ============================================================
    # Deploy or Update Application in Kubernetes
    # ============================================================
    - name: Apply Kubernetes Deployment, Service, and Ingress
      shell: |
        cat <<EOF | /snap/bin/microk8s kubectl apply -f -
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: {{ app_name }}
          namespace: {{ k8s_namespace }}
        spec:
          replicas: 2
          selector:
            matchLabels:
              app: {{ app_name }}
          template:
            metadata:
              labels:
                app: {{ app_name }}
            spec:
              containers:
              - name: {{ app_name }}
                image: {{ docker_registry }}:{{ app_version }}
                imagePullPolicy: IfNotPresent
                ports:
                - containerPort: 3000
                  name: http
                - containerPort: {{ https_port }}
                  name: https
                envFrom:
                - secretRef:
                    name: school-portal-secrets
                env:
                - name: NODE_ENV
                  value: "production"
                - name: HTTPS_PORT
                  value: "{{ https_port }}"
                - name: CERT_PATH
                  value: "/app/certs/cert.pem"
                - name: KEY_PATH
                  value: "/app/certs/key.pem"
                volumeMounts:
                - name: ssl-certs
                  mountPath: /app/certs
                  readOnly: true
                resources:
                  requests:
                    memory: "256Mi"
                    cpu: "250m"
                  limits:
                    memory: "512Mi"
                    cpu: "500m"
                livenessProbe:
                  httpGet:
                    path: /
                    port: {{ https_port }}
                    scheme: HTTPS
                  initialDelaySeconds: 30
                  periodSeconds: 10
                readinessProbe:
                  httpGet:
                    path: /
                    port: {{ https_port }}
                    scheme: HTTPS
                  initialDelaySeconds: 10
                  periodSeconds: 5
              volumes:
              - name: ssl-certs
                configMap:
                  name: ssl-certs
        ---
        apiVersion: v1
        kind: Service
        metadata:
          name: {{ app_name }}-service
          namespace: {{ k8s_namespace }}
        spec:
          type: ClusterIP
          selector:
            app: {{ app_name }}
          ports:
          - name: https
            protocol: TCP
            port: {{ https_port }}
            targetPort: {{ https_port }}
        ---
        apiVersion: networking.k8s.io/v1
        kind: Ingress
        metadata:
          name: {{ app_name }}-ingress
          namespace: {{ k8s_namespace }}
          annotations:
            nginx.ingress.kubernetes.io/ssl-redirect: "true"
            nginx.ingress.kubernetes.io/backend-protocol: "HTTPS"
            nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
        spec:
          ingressClassName: nginx
          rules:
          - host: {{ production_domain | default(production_ip) }}
            http:
              paths:
              - path: /
                pathType: Prefix
                backend:
                  service:
                    name: {{ app_name }}-service
                    port:
                      number: {{ https_port }}
        EOF
      args:
        executable: /bin/bash
      changed_when: true

    # ============================================================
    # Wait for Application Readiness
    # ============================================================
    - name: Wait for pods to be ready
      command: /snap/bin/microk8s kubectl wait --for=condition=ready pod -l app={{ app_name }} -n {{ k8s_namespace }} --timeout=120s
      register: pods_wait
      changed_when: false
      failed_when: false

    - name: Get deployment status
      command: /snap/bin/microk8s kubectl get pods -n {{ k8s_namespace }} -l app={{ app_name }}
      register: pods_status
      changed_when: false

    - name: Get service status
      command: /snap/bin/microk8s kubectl get svc {{ app_name }}-service -n {{ k8s_namespace }}
      register: service_status
      changed_when: false

    - name: Get ingress status
      command: /snap/bin/microk8s kubectl get ingress {{ app_name }}-ingress -n {{ k8s_namespace }}
      register: ingress_status
      changed_when: false

    # ============================================================
    # Summary Output
    # ============================================================
    - name: Display deployment information
      debug:
        msg: |

          â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
          â•‘                                                                      â•‘
          â•‘              âœ…  APPLICATION DEPLOYED SUCCESSFULLY!  âœ…              â•‘
          â•‘                                                                      â•‘
          â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

          ðŸŒ Application URL: {{ redirect_uri }}
          ðŸ“¦ Version: {{ app_version }}

          ðŸ“Š Pods:
          {{ pods_status.stdout }}

          ðŸŒ Service:
          {{ service_status.stdout }}

          ðŸŒ Ingress:
          {{ ingress_status.stdout }}

          âš ï¸  Make sure Azure AD has redirect URI: {{ redirect_uri }}

          ðŸŽ‰ Ready to use!

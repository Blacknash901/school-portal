---
# ============================================================================
# Application Deployment Playbook
# ============================================================================
#
# PURPOSE:
#   Deploy or update the School Portal application on the production server.
#   This version is CI/CD ready â€” intended to be triggered automatically by
#   GitHub Actions on a self-hosted runner (same server where MicroK8s runs).
#
# USAGE (manual):
#   ansible-playbook -i inventory-production.yml deploy-app.yml
#
# DEPLOYMENT TIME: ~2-3 minutes
#
# PREREQUISITES:
#   - Infrastructure setup complete (run setup-infrastructure.yml first)
#   - Docker image already pushed to Docker Hub
#   - `.env` file is generated by GitHub Actions and placed in repo root
#
# ============================================================================

- name: Deploy School Portal Application
  hosts: production-server
  become: yes
  gather_facts: yes

  vars:
    # Logic: Use Domain if (use_ip is false AND domain is set), otherwise use IP
    use_domain: "{{ not use_ip|bool and (production_domain | default('', true) | length > 0) }}"
    redirect_uri: "{{ 'https://' + (production_domain | default('', true)) if use_domain else ('https://' + production_ip + ':30443' if use_https|bool else 'http://' + production_ip + ':3000') }}"
    https_port: "{{ 443 if use_domain else (3443 if use_https|bool else 443) }}"
    app_path: "/opt/{{ app_name }}"
    certs_path: "/opt/{{ app_name }}/certs"

  tasks:
    # ============================================================
    # Debug Variables
    # ============================================================
    - name: Debug deployment variables
      debug:
        msg:
          - "production_domain: '{{ production_domain }}'"
          - "use_ip: '{{ use_ip }}'"
          - "use_https: '{{ use_https }}'"
          - "production_ip: '{{ production_ip }}'"
          - "use_domain (calculated): '{{ use_domain }}'"

    # ============================================================
    # Prepare Application Directory
    # ============================================================
    - name: Create application directory
      file:
        path: "{{ app_path }}"
        state: directory
        mode: "0755"

    - name: Copy .env file from workflow
      copy:
        src: "{{ playbook_dir }}/../../.env"
        dest: "{{ app_path }}/.env"
        mode: "0600"
      when: lookup('file', playbook_dir + '/../../.env', errors='ignore') != ''
      changed_when: true

    - name: Create certs directory
      file:
        path: "{{ certs_path }}"
        state: directory
        mode: "0755"

    - name: Generate self-signed SSL certificate if not exists
      command: >
        openssl req -x509 -nodes -days 365 -newkey rsa:2048
        -keyout {{ certs_path }}/key.pem
        -out {{ certs_path }}/cert.pem
        -subj "/C=US/ST=State/L=City/O=Organization/CN={{ production_ip }}"
      args:
        creates: "{{ certs_path }}/cert.pem"
      changed_when: true

    - name: Set certificate permissions
      file:
        path: "{{ certs_path }}/{{ item }}"
        mode: "0644"
      loop:
        - cert.pem
        - key.pem
      changed_when: false

    # ============================================================
    # Pull Docker Image and Import into MicroK8s
    # ============================================================
    - name: Pull Docker image from Docker Hub
      community.docker.docker_image:
        name: "{{ docker_registry }}:{{ app_version }}"
        source: pull
      register: pull_result
      changed_when: "'Pulled' in (pull_result.actions | join(' '))"

    - name: Import image into MicroK8s containerd
      shell: |
        docker save {{ docker_registry }}:{{ app_version }} -o /tmp/app-{{ app_version }}.tar
        microk8s ctr images import /tmp/app-{{ app_version }}.tar
        rm /tmp/app-{{ app_version }}.tar
      args:
        executable: /bin/bash
      changed_when: true

    # ============================================================
    # Create/Update Kubernetes Resources
    # ============================================================
    - name: Create clean .env file for Kubernetes secrets
      shell: |
        awk -F'=' '!seen[$1]++ && $1 !~ /^#/ && $1 !~ /^CERT_PATH$/ && $1 !~ /^KEY_PATH$/' {{ app_path }}/.env > {{ app_path }}/.env.k8s
      args:
        executable: /bin/bash
      changed_when: true

    - name: Create or update Kubernetes secret
      shell: |
        /snap/bin/microk8s kubectl create secret generic school-portal-secrets \
          --from-env-file={{ app_path }}/.env.k8s \
          --namespace={{ k8s_namespace }} \
          --dry-run=client -o yaml | /snap/bin/microk8s kubectl apply -f -
      args:
        executable: /bin/bash
      changed_when: true

    - name: Create or update SSL certificate ConfigMap
      shell: |
        /snap/bin/microk8s kubectl create configmap ssl-certs \
          --from-file=cert.pem={{ certs_path }}/cert.pem \
          --from-file=key.pem={{ certs_path }}/key.pem \
          --namespace={{ k8s_namespace }} \
          --dry-run=client -o yaml | /snap/bin/microk8s kubectl apply -f -
      args:
        executable: /bin/bash
      changed_when: true

    # ============================================================
    # Deploy or Update Application in Kubernetes
    # ============================================================
    - name: Create Kubernetes manifest file
      copy:
        dest: "/tmp/k8s-deployment.yaml"
        content: |
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: {{ app_name }}
            namespace: {{ k8s_namespace }}
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: {{ app_name }}
            template:
              metadata:
                labels:
                  app: {{ app_name }}
              spec:
                containers:
                - name: {{ app_name }}
                  image: {{ docker_registry }}:{{ app_version }}
                  imagePullPolicy: IfNotPresent
                  ports:
                  - containerPort: 3000
                    name: http
                  - containerPort: {{ https_port }}
                    name: https
                  envFrom:
                  - secretRef:
                      name: school-portal-secrets
                  env:
                  - name: NODE_ENV
                    value: "production"
                  - name: HTTPS_PORT
                    value: "{{ https_port }}"
                  - name: CERT_PATH
                    value: "/app/certs/cert.pem"
                  - name: KEY_PATH
                    value: "/app/certs/key.pem"
                  volumeMounts:
                  - name: ssl-certs
                    mountPath: /app/certs
                    readOnly: true
                  resources:
                    requests:
                      memory: "256Mi"
                      cpu: "250m"
                    limits:
                      memory: "512Mi"
                      cpu: "500m"
                  livenessProbe:
                    httpGet:
                      path: /
                      port: {{ https_port }}
                      scheme: HTTPS
                    initialDelaySeconds: 30
                    periodSeconds: 10
                  readinessProbe:
                    httpGet:
                      path: /
                      port: {{ https_port }}
                      scheme: HTTPS
                    initialDelaySeconds: 10
                    periodSeconds: 5
                volumes:
                - name: ssl-certs
                  configMap:
                    name: ssl-certs
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: {{ app_name }}-service
            namespace: {{ k8s_namespace }}
          spec:
            type: ClusterIP
            selector:
              app: {{ app_name }}
            ports:
            - name: https
              protocol: TCP
              port: {{ https_port }}
              targetPort: {{ https_port }}
          ---
          apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: {{ app_name }}-ingress
            namespace: {{ k8s_namespace }}
            annotations:
              nginx.ingress.kubernetes.io/ssl-redirect: "true"
              nginx.ingress.kubernetes.io/backend-protocol: "HTTPS"
              nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
          spec:
            ingressClassName: nginx
            rules:
            # Ingress Rule (Updated Logic)
            {% if use_domain | bool %}
              - host: {{ production_domain }}
                http:
                  paths:
                    - path: /
                      pathType: Prefix
                      backend:
                        service:
                          name: {{ app_name }}-service
                          port:
                            number: {{ https_port }}
            {% else %}
              - http:
                  paths:
                    - path: /
                      pathType: Prefix
                      backend:
                        service:
                          name: {{ app_name }}-service
                          port:
                            number: {{ https_port }}
            {% endif %}

    - name: Delete existing Ingress to avoid patch issues
      command: /snap/bin/microk8s kubectl delete ingress {{ app_name }}-ingress -n {{ k8s_namespace }} --ignore-not-found=true

    - name: Apply Kubernetes Deployment, Service, and Ingress
      command: /snap/bin/microk8s kubectl apply -f /tmp/k8s-deployment.yaml
      register: apply_result
      ignore_errors: yes

    - name: Describe Pods (Debug)
      shell: |
        /snap/bin/microk8s kubectl describe pods -n {{ k8s_namespace }} -l app={{ app_name }}
      register: pod_description
      ignore_errors: yes
      when: apply_result.failed

    - name: Print Pod Description
      debug:
        var: pod_description.stdout_lines
      when: apply_result.failed

    - name: Fail if deployment failed
      fail:
        msg: "Deployment failed. Check logs above."
      when: apply_result.failed

    # ============================================================
    # Wait for Application Readiness
    # ============================================================
    - name: Wait for pods to be ready
      command: /snap/bin/microk8s kubectl wait --for=condition=ready pod -l app={{ app_name }} -n {{ k8s_namespace }} --timeout=120s
      register: pods_wait
      changed_when: false
      failed_when: false

    - name: Get deployment status
      command: /snap/bin/microk8s kubectl get pods -n {{ k8s_namespace }} -l app={{ app_name }}
      register: pods_status
      changed_when: false

    - name: Get service status
      command: /snap/bin/microk8s kubectl get svc {{ app_name }}-service -n {{ k8s_namespace }}
      register: service_status
      changed_when: false

    - name: Get ingress status
      command: /snap/bin/microk8s kubectl get ingress {{ app_name }}-ingress -n {{ k8s_namespace }}
      register: ingress_status
      changed_when: false

    # ============================================================
    # Summary Output
    # ============================================================
    - name: Display deployment information
      debug:
        msg: |

          â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
          â•‘                                                                      â•‘
          â•‘              âœ…  APPLICATION DEPLOYED SUCCESSFULLY!  âœ…              â•‘
          â•‘                                                                      â•‘
          â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

          ğŸŒ Application URL: {{ redirect_uri }}
          ğŸ“¦ Version: {{ app_version }}

          ğŸ“Š Pods:
          {{ pods_status.stdout }}

          ğŸŒ Service:
          {{ service_status.stdout }}

          ğŸŒ Ingress:
          {{ ingress_status.stdout }}

          âš ï¸  Make sure Azure AD has redirect URI: {{ redirect_uri }}

          ğŸ‰ Ready to use!

name: Deploy Complete Stack

on:
  workflow_dispatch:
    inputs:
      deploy_type:
        description: "Deployment Scope"
        required: true
        default: "all"
        type: choice
        options:
          - all
          - infra-only
          - portal-only
          - monitor-stack-only
          - monitor-app-only
      portal_version:
        description: "Portal App Version (leave empty for package.json)"
        required: false
        type: string
      monitor_version:
        description: "Monitor App Version (leave empty for latest)"
        required: false
        type: string

env:
  DOCKER_REGISTRY_PORTAL: blacknash/cecre
  DOCKER_REGISTRY_MONITOR: blacknash/monitor

jobs:
  # ============================================================================
  # JOB 1: DEPLOY INFRASTRUCTURE (Terraform Only)
  # ============================================================================
  deploy-infra:
    name: 1. Deploy Infrastructure
    runs-on: ubuntu-latest
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_REGION: us-east-1
      TF_VAR_aws_access_key: ${{ secrets.AWS_ACCESS_KEY_ID }}
      TF_VAR_aws_secret_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      TF_API_TOKEN: ${{ secrets.TF_API_TOKEN }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.9.0
          cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

      - name: Terraform Init
        working-directory: ./infrastructure/terraform
        run: terraform init -input=false

      - name: Terraform Validate
        working-directory: ./infrastructure/terraform
        run: terraform validate

      - name: Terraform Plan
        working-directory: ./infrastructure/terraform
        run: terraform plan -out=tfplan -input=false

      - name: Terraform Apply
        if: ${{ github.event.inputs.deploy_type == 'all' || github.event.inputs.deploy_type == 'infra-only' }}
        working-directory: ./infrastructure/terraform
        run: terraform apply -auto-approve -input=false tfplan

      - name: Ping Infrastructure
        continue-on-error: true
        working-directory: ./infrastructure/terraform
        run: |
          IP=$(terraform output -raw ec2_instance_1_public_ip)
          echo "Pinging $IP..."
          ping -c 3 $IP || true

  # ============================================================================
  # JOB 2: DEPLOY PORTAL APP
  # ============================================================================
  deploy-portal:
    name: 2. Deploy Portal App
    needs: deploy-infra
    if: ${{ always() && (github.event.inputs.deploy_type == 'all' || github.event.inputs.deploy_type == 'portal-only') && needs.deploy-infra.result != 'failure' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Extract version from package.json
        id: version
        run: |
          VERSION="${{ github.event.inputs.portal_version }}"
          if [ -z "$VERSION" ]; then
            VERSION=$(node -p "require('./portal-app/package.json').version")
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "App version: $VERSION"

      - name: Set deployment type
        id: deploy_type
        run: |
          TYPE="${{ github.event.inputs.deploy_type }}"
          if [ "$TYPE" == "portal-only" ]; then
            TYPE="app"
          fi
          if [ -z "$TYPE" ]; then
            TYPE="app"
          fi
          echo "type=$TYPE" >> $GITHUB_OUTPUT
          echo "Deployment type: $TYPE"

      - name: Generate .env file from GitHub secrets
        run: |
          cat > .env <<EOF
          # Generated from GitHub Secrets - DO NOT COMMIT
          # Azure Active Directory
          REACT_APP_MSAL_CLIENT_ID=${{ secrets.REACT_APP_MSAL_CLIENT_ID }}
          REACT_APP_MSAL_TENANT_ID=${{ secrets.REACT_APP_MSAL_TENANT_ID }}
          REACT_APP_AZURE_CLIENT_ID=${{ secrets.REACT_APP_AZURE_CLIENT_ID }}
          REACT_APP_AZURE_TENANT_ID=${{ secrets.REACT_APP_AZURE_TENANT_ID }}
          REACT_APP_REDIRECT_URI=${{ secrets.REACT_APP_REDIRECT_URI }}

          # AWS S3 Logging
          REACT_APP_S3_BUCKET_NAME=${{ secrets.REACT_APP_S3_BUCKET_NAME }}
          REACT_APP_S3_REGION=${{ secrets.REACT_APP_S3_REGION }}
          REACT_APP_S3_ACCESS_KEY_ID=${{ secrets.REACT_APP_S3_ACCESS_KEY_ID }}
          REACT_APP_S3_SECRET_ACCESS_KEY=${{ secrets.REACT_APP_S3_SECRET_ACCESS_KEY }}
          AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION=${{ secrets.AWS_REGION }}
          S3_BUCKET_NAME=${{ secrets.S3_BUCKET_NAME }}

          # Sentry Error Tracking
          REACT_APP_SENTRY_DSN=${{ secrets.REACT_APP_SENTRY_DSN }}
          REACT_APP_SENTRY_ENVIRONMENT=${{ secrets.REACT_APP_SENTRY_ENVIRONMENT }}
          REACT_APP_ENABLE_SENTRY=${{ secrets.REACT_APP_ENABLE_SENTRY }}
          SENTRY_DSN=${{ secrets.SENTRY_DSN }}

          # WordPress RSS Feed
          REACT_APP_WORDPRESS_FEED_URL=${{ secrets.REACT_APP_WORDPRESS_FEED_URL }}

          # Google OAuth
          REACT_APP_GOOGLE_CLIENT_ID=${{ secrets.REACT_APP_GOOGLE_CLIENT_ID }}

          # Server Configuration
          NODE_ENV=production
          PORT=3000
          HTTPS_PORT=443
          EOF
          echo "âœ… .env file generated"

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.9.0
          cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}
          terraform_wrapper: false

      - name: Fetch Terraform Outputs
        id: tf_outputs
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: us-east-1
        run: |
          cd infrastructure/terraform
          terraform init -input=false

          IP=$(terraform output -raw ec2_instance_1_public_ip)
          terraform output -raw private_key_pem > ../../private_key.pem
          chmod 600 ../../private_key.pem

          echo "ip=$IP" >> $GITHUB_OUTPUT
          echo "âœ… Fetched IP: $IP"

      - name: Determine production domain
        id: production_domain
        env:
          PRODUCTION_DOMAIN_SECRET: ${{ secrets.PRODUCTION_DOMAIN }}
        run: |
          DOMAIN="$PRODUCTION_DOMAIN_SECRET"
          if [ -z "$DOMAIN" ]; then
            DOMAIN="portal.cecre.net"
          fi
          echo "domain=$DOMAIN" >> $GITHUB_OUTPUT
          echo "âœ… Using production domain: $DOMAIN"

      - name: Generate dynamic inventory file
        run: |
          mkdir -p deployment/ansible
          cat > deployment/ansible/inventory-github.yml <<EOF
          all:
            hosts:
              production-server:
                ansible_host: ${{ steps.tf_outputs.outputs.ip }}
                ansible_user: ubuntu
                ansible_ssh_private_key_file: ${{ github.workspace }}/private_key.pem
                ansible_python_interpreter: /usr/bin/python3
                ansible_ssh_common_args: "-o StrictHostKeyChecking=no"
                ansible_become: true
                ansible_become_method: sudo
                ansible_become_password: ""
                ansible_become_flags: "-n"

            vars:
              app_name: school-portal
              app_version: "${{ steps.version.outputs.version }}"
              docker_registry: ${{ env.DOCKER_REGISTRY_PORTAL }}
              production_ip: ${{ steps.tf_outputs.outputs.ip }}
              production_domain: "${{ steps.production_domain.outputs.domain }}"
              use_ip: "${{ secrets.USE_IP || 'false' }}"
              use_https: "${{ secrets.USE_HTTPS || 'true' }}"
              letsencrypt_email: ${{ secrets.LETSENCRYPT_EMAIL }}
              k8s_namespace: ${{ secrets.K8S_NAMESPACE || 'default' }}
          EOF
          echo "âœ… Inventory file generated"

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          # Key is already saved to private_key.pem in workspace root
          ssh-keyscan -H ${{ steps.tf_outputs.outputs.ip }} >> ~/.ssh/known_hosts 2>/dev/null || true
          echo "âœ… SSH key configured"

      - name: Check Infrastructure Status
        id: check_infra
        run: |
          echo "ðŸ” Checking if MicroK8s is installed on ${{ steps.tf_outputs.outputs.ip }}..."
          if ssh -o StrictHostKeyChecking=no -i private_key.pem ubuntu@${{ steps.tf_outputs.outputs.ip }} "which microk8s"; then
            echo "âœ… Infrastructure is ready"
            echo "ready=true" >> $GITHUB_OUTPUT
          else
            echo "âš ï¸ Infrastructure missing (MicroK8s not found)"
            echo "ready=false" >> $GITHUB_OUTPUT
          fi

      - name: Install Ansible
        run: |
          sudo apt-get update
          sudo apt-get install -y python3-pip
          pip3 install ansible
          ansible --version
          echo "âœ… Ansible installed"

      - name: Deploy with Ansible
        run: |
          cd deployment/ansible

          DEPLOY_TYPE="${{ steps.deploy_type.outputs.type }}"
          INFRA_READY="${{ steps.check_infra.outputs.ready }}"

          # Smart Deployment Logic
          if [ "$INFRA_READY" == "false" ]; then
            echo "âš ï¸ Infrastructure is missing. Forcing full deployment (Infrastructure + App)."
            DEPLOY_TYPE="all"
          fi

          case $DEPLOY_TYPE in
            "all")
              echo "ðŸš€ Deploying everything (infrastructure + app)..."
              ansible-playbook -i inventory-github.yml deploy-all.yml
              ;;
            "monitoring")
              echo "ðŸ“Š Deploying monitoring only..."
              ansible-playbook -i inventory-github.yml deploy-monitoring.yml
              ;;
            "app"|*)
              echo "ðŸ“¦ Deploying application only..."
              ansible-playbook -i inventory-github.yml deploy-app.yml
              ;;
          esac

      - name: Cleanup
        if: always()
        run: |
          rm -f private_key.pem
          echo "âœ… Cleanup completed"

      - name: Deployment summary
        if: success()
        run: |
          echo "âœ… Deployment completed successfully!"
          echo "ðŸ“¦ Version: ${{ steps.version.outputs.version }}"
          echo "ðŸŒ URL: ${{ secrets.REACT_APP_REDIRECT_URI }}"

      - name: Test Portal App (Curl)
        run: |
          # Wait a bit for ingress
          sleep 30
          curl -k -v https://${{ steps.tf_outputs.outputs.ip }}:3443 || curl -v http://${{ steps.tf_outputs.outputs.ip }}:3000

  # ============================================================================
  # JOB 3: DEPLOY MONITOR APP
  # ============================================================================
  deploy-monitor-app:
    name: 3. Deploy Monitor App
    needs: [deploy-infra, deploy-portal]
    if: ${{ always() && (github.event.inputs.deploy_type == 'all' || github.event.inputs.deploy_type == 'monitor-app-only') && needs.deploy-infra.result != 'failure' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Extract Monitor Version
        id: monitor_ver
        run: |
          VERSION="${{ github.event.inputs.monitor_version }}"
          if [ -z "$VERSION" ]; then
            VERSION="latest"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      # --- Fetch Infrastructure Info ---
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.9.0
          cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

      - name: Fetch Terraform Outputs
        id: tf_outputs
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: us-east-1
        run: |
          cd infrastructure/terraform
          terraform init -input=false
          IP=$(terraform output -raw ec2_instance_1_public_ip)
          terraform output -raw private_key_pem > ../../private_key.pem
          chmod 600 ../../private_key.pem
          echo "ip=$IP" >> $GITHUB_OUTPUT

          # Setup SSH for Ansible
          mkdir -p ~/.ssh
          cp ../../private_key.pem ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

      - name: Install Ansible
        run: |
          sudo apt-get update
          sudo apt-get install -y python3-pip
          pip3 install ansible

      - name: Generate Inventory
        run: |
          mkdir -p deployment/ansible
          cat > deployment/ansible/inventory-github.yml <<EOF
          all:
            hosts:
              production-server:
                ansible_host: ${{ steps.tf_outputs.outputs.ip }}
                ansible_user: ubuntu
                ansible_ssh_private_key_file: ~/.ssh/id_rsa
                ansible_python_interpreter: /usr/bin/python3
                ansible_ssh_common_args: "-o StrictHostKeyChecking=no"
                ansible_become: true
                ansible_become_method: sudo
                ansible_become_flags: "-n"
            vars:
              docker_registry: ${{ env.DOCKER_REGISTRY_MONITOR }}
              app_version: "${{ steps.monitor_ver.outputs.version }}"
              monitoring_namespace: monitoring
          EOF

      - name: Deploy Monitor App
        working-directory: ./deployment/ansible
        run: ansible-playbook -i inventory-github.yml deploy-monitor-app.yml

      - name: Test Monitor App
        run: |
          ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa ubuntu@${{ steps.tf_outputs.outputs.ip }} "/snap/bin/microk8s kubectl get pods -n monitoring -l app=monitor-app | grep monitor-app"

  # ============================================================================
  # JOB 4: DEPLOY MONITORING STACK (Prometheus/Grafana)
  # ============================================================================
  deploy-monitor-stack:
    name: 4. Deploy Monitoring Stack
    needs: [deploy-infra, deploy-monitor-app]
    if: ${{ always() && (github.event.inputs.deploy_type == 'all' || github.event.inputs.deploy_type == 'monitor-stack-only') && needs.deploy-infra.result != 'failure' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      # --- Fetch Infrastructure Info ---
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.9.0
          cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

      - name: Fetch Terraform Outputs
        id: tf_outputs
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: us-east-1
        run: |
          cd infrastructure/terraform
          terraform init -input=false
          IP=$(terraform output -raw ec2_instance_1_public_ip)
          terraform output -raw private_key_pem > ../../private_key.pem
          chmod 600 ../../private_key.pem
          echo "ip=$IP" >> $GITHUB_OUTPUT

          # Setup SSH for Ansible
          mkdir -p ~/.ssh
          cp ../../private_key.pem ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

      - name: Install Ansible
        run: |
          sudo apt-get update
          sudo apt-get install -y python3-pip
          pip3 install ansible

      - name: Generate Inventory
        run: |
          mkdir -p deployment/ansible
          cat > deployment/ansible/inventory-github.yml <<EOF
          all:
            hosts:
              production-server:
                ansible_host: ${{ steps.tf_outputs.outputs.ip }}
                ansible_user: ubuntu
                ansible_ssh_private_key_file: ~/.ssh/id_rsa
                ansible_python_interpreter: /usr/bin/python3
                ansible_ssh_common_args: "-o StrictHostKeyChecking=no"
                ansible_become: true
                ansible_become_method: sudo
                ansible_become_flags: "-n"
            vars:
              monitoring_namespace: monitoring
          EOF

      - name: Deploy Monitoring Stack
        working-directory: ./deployment/ansible
        run: ansible-playbook -i inventory-github.yml deploy-monitoring-stack.yml

      - name: Test Monitoring Stack
        run: |
          ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa ubuntu@${{ steps.tf_outputs.outputs.ip }} "/snap/bin/microk8s kubectl get pods -n monitoring -l app=prometheus | grep prometheus"

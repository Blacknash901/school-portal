name: Deploy Complete Stack

on:
  workflow_dispatch:
    inputs:
      deploy_type:
        description: "Deployment Scope"
        required: true
        default: "all"
        type: choice
        options:
          - all
          - infra-only
          - portal-only
          - monitor-stack-only
          - monitor-app-only
      portal_version:
        description: "Portal App Version (leave empty for package.json)"
        required: false
        type: string
      monitor_version:
        description: "Monitor App Version (leave empty for latest)"
        required: false
        type: string

env:
  DOCKER_REGISTRY_PORTAL: blacknash/cecre
  DOCKER_REGISTRY_MONITOR: blacknash/monitor

jobs:
  deploy:
    name: Deploy Complete Stack
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      # --- Version Extraction ---
      - name: Extract Portal Version
        id: portal_ver
        run: |
          VERSION="${{ github.event.inputs.portal_version }}"
          if [ -z "$VERSION" ]; then
            VERSION=$(node -p "require('./portal-app/package.json').version")
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Extract Monitor Version
        id: monitor_ver
        run: |
          VERSION="${{ github.event.inputs.monitor_version }}"
          if [ -z "$VERSION" ]; then
            VERSION="latest"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      # --- Secrets & Env ---
      - name: Generate .env file
        run: |
          cat > .env <<EOF
          # Generated from GitHub Secrets
          REACT_APP_MSAL_CLIENT_ID=${{ secrets.REACT_APP_MSAL_CLIENT_ID }}
          REACT_APP_MSAL_TENANT_ID=${{ secrets.REACT_APP_MSAL_TENANT_ID }}
          REACT_APP_AZURE_CLIENT_ID=${{ secrets.REACT_APP_AZURE_CLIENT_ID }}
          REACT_APP_AZURE_TENANT_ID=${{ secrets.REACT_APP_AZURE_TENANT_ID }}
          REACT_APP_REDIRECT_URI=${{ secrets.REACT_APP_REDIRECT_URI }}
          REACT_APP_S3_BUCKET_NAME=${{ secrets.REACT_APP_S3_BUCKET_NAME }}
          REACT_APP_S3_REGION=${{ secrets.REACT_APP_S3_REGION }}
          REACT_APP_S3_ACCESS_KEY_ID=${{ secrets.REACT_APP_S3_ACCESS_KEY_ID }}
          REACT_APP_S3_SECRET_ACCESS_KEY=${{ secrets.REACT_APP_S3_SECRET_ACCESS_KEY }}
          AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION=${{ secrets.AWS_REGION }}
          S3_BUCKET_NAME=${{ secrets.S3_BUCKET_NAME }}
          REACT_APP_SENTRY_DSN=${{ secrets.REACT_APP_SENTRY_DSN }}
          REACT_APP_SENTRY_ENVIRONMENT=${{ secrets.REACT_APP_SENTRY_ENVIRONMENT }}
          REACT_APP_ENABLE_SENTRY=${{ secrets.REACT_APP_ENABLE_SENTRY }}
          SENTRY_DSN=${{ secrets.SENTRY_DSN }}
          REACT_APP_WORDPRESS_FEED_URL=${{ secrets.REACT_APP_WORDPRESS_FEED_URL }}
          REACT_APP_GOOGLE_CLIENT_ID=${{ secrets.REACT_APP_GOOGLE_CLIENT_ID }}
          NODE_ENV=production
          PORT=3000
          HTTPS_PORT=443
          EOF

      # --- Terraform ---
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.9.0
          cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}
          terraform_wrapper: false

      - name: Fetch Terraform Outputs
        id: tf_outputs
        env:
          TF_IN_AUTOMATION: true
        run: |
          cd infrastructure/terraform
          terraform init -input=false
          IP=$(terraform output -raw ec2_instance_1_public_ip)
          terraform output -raw private_key_pem > ../../private_key.pem
          chmod 600 ../../private_key.pem
          echo "ip=$IP" >> $GITHUB_OUTPUT

      - name: Determine Domain
        id: domain
        run: |
          DOMAIN="${{ secrets.PRODUCTION_DOMAIN }}"
          [ -z "$DOMAIN" ] && DOMAIN="portal.cecre.net"
          echo "domain=$DOMAIN" >> $GITHUB_OUTPUT

      # --- Ansible Inventory ---
      - name: Generate Inventory
        run: |
          mkdir -p deployment/ansible
          cat > deployment/ansible/inventory-github.yml <<EOF
          all:
            hosts:
              production-server:
                ansible_host: ${{ steps.tf_outputs.outputs.ip }}
                ansible_user: ubuntu
                ansible_ssh_private_key_file: ${{ github.workspace }}/private_key.pem
                ansible_python_interpreter: /usr/bin/python3
                ansible_ssh_common_args: "-o StrictHostKeyChecking=no"
                ansible_become: true
                ansible_become_method: sudo
                ansible_become_flags: "-n"
            vars:
              # Portal App Vars
              app_name: school-portal
              app_version: "${{ steps.portal_ver.outputs.version }}"
              docker_registry: ${{ env.DOCKER_REGISTRY_PORTAL }}
              production_ip: ${{ steps.tf_outputs.outputs.ip }}
              production_domain: "${{ steps.domain.outputs.domain }}"
              use_ip: "${{ secrets.USE_IP || 'false' }}"
              use_https: "${{ secrets.USE_HTTPS || 'true' }}"
              letsencrypt_email: ${{ secrets.LETSENCRYPT_EMAIL }}
              k8s_namespace: ${{ secrets.K8S_NAMESPACE || 'default' }}
              
              # Monitor App Vars
              monitor_app_name: monitor-app
              monitor_docker_registry: ${{ env.DOCKER_REGISTRY_MONITOR }}
              monitor_app_version: "${{ steps.monitor_ver.outputs.version }}"
              monitoring_namespace: monitoring
          EOF

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ steps.tf_outputs.outputs.ip }} >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: Install Ansible
        run: |
          sudo apt-get update
          sudo apt-get install -y python3-pip
          pip3 install ansible

      # --- Deployment Logic ---
      - name: Run Deployment
        working-directory: ./deployment/ansible
        run: |
          TYPE="${{ github.event.inputs.deploy_type }}"

          case $TYPE in
            "all")
              ansible-playbook -i inventory-github.yml deploy-complete.yml
              ;;
            "infra-only")
              ansible-playbook -i inventory-github.yml setup-infrastructure.yml
              ;;
            "portal-only")
              ansible-playbook -i inventory-github.yml deploy-app.yml
              ;;
            "monitor-stack-only")
              ansible-playbook -i inventory-github.yml deploy-monitoring-stack.yml
              ;;
            "monitor-app-only")
              # Override vars for monitor app specific deployment if needed, 
              # but inventory vars should cover it.
              # Note: deploy-monitor-app.yml expects 'docker_registry' and 'app_version' 
              # which are generic names. We need to pass them explicitly or update playbook.
              # Let's pass them as extra vars to be safe.
              ansible-playbook -i inventory-github.yml deploy-monitor-app.yml \
                -e "docker_registry=${{ env.DOCKER_REGISTRY_MONITOR }}" \
                -e "app_version=${{ steps.monitor_ver.outputs.version }}"
              ;;
          esac

      - name: Cleanup
        if: always()
        run: rm -f private_key.pem
